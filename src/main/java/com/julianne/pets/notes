////
some notes I took while learning
////

layers of abstraction
1. database (mySQL) - interact with it through SQL queries
2. JDBC (Java Database Connectivity) - connects Java code to mySQL database, the connection is being set up in application.properties
3. Hibernate (default Spring Boot ORM - Object Relational Mapper) - implements JPA rules, maps Java Objects to relationships in the database
   //// other ORMs - OpenJPA, MyBatis
   //// the company that builds houses and follows the laws of the government (JPA)
4. JPA (Java Persistence API) - rules to connect Java to the SQL database
   //// the government making a list of rules to build a house
5. Spring Data JPA - lets you write plain english and spring does the conversion with the orm to autogenerate the sql query for you
   //// because there is a way where you could be just writing queries in the code


unit testing
 / tests are written in given/when/then format - arrange/act/assert
 // given a product exists, when user gets product by id, then return a product dto
 /// don't test things built into spring (service, restcontroller, controller endpoints, .save method from jpa)
 //// don't interact with database

 ///// test code we wrote - dto constructors, service logic, validators
 ///// should test every logical path for the program to take
 ///// paths: finds product - return dto && can't find product - throw product not found exception

 @mock - mock the response from the repository
 @injectmocks - service class we are testing
 @beforeeach - test up (initiate the mock object)
 @test - for each test we write


 headers
 1. accept - what kind of media you can receive (return either JSON/XML)
 2. authorization
 3. cookies


 cascade / fetch
 1. CascadeType.All - if you update the Customer it wll automatically update the address
 2. FetchType.EAGER - when getting a Customer automatically get the Address
 3. FetchType.LAZY - when getting a Customer don't automatically get the Address

 json ignore
 - when constructing the JSON response there was a circular reference,
   with this you ignore the property when constructing JSON to avoid circular reference

logging - replace sout with logger.info
1. fatal - app crash
2. error - error but app keeps running
3. warn - many lead to an error
4. info - show progress of app
5. debug / trace
- log aggregator - splunk - sends logs to a central location so you can document & search through them
/ SLF4J - simple logging facade for java - others: log4j, logback, java util logging

caching - moving some data from the database to a memory on the server - quicker response time
// do - when data doesn't change often or many users are trying to get the same data all at once
// don't - when it has to be 100% correct and up to date, if performance isn't an issue
- cache manager - SB default cache annotations
1. EnableCaching
2. Cacheable
3. CacheEvict
4. CachePut

external apis - needed when getting data from someone else's backend
// you want the weather data - ping the service and return what you need
// apps using someone else's backend for your authentication
- use Rest Template - HTTP client from Spring - allows us to make HTTP requests

authentication
// authenticated endpoint - need to provide credentials to access
// unauthenticated endpoint - don't need to provide credentials to access
/// web shops - you can browse products but can't purchase them or add the to the wishlist

cross site request forgery
// only works for get's - to work on others you need to disable csrf
/// because get only looks at resources while others mutate the underlying data

authorization - set up in 2 ways:
// authority - what you can do - special or basic access
// roles - who you are - manager, employee
/// security filter chain or method level security
//// this is using the UserDetailsService in memory

spring security flow
1. a http request comes in
2. it goes through the security filter chain
3. if the basic auth is in the header then the basic auth filter triggered
4. basic auth filter then calls the auth manager
5. auth manager calls the user details service
6. user details service than calls the loadUserByUsername method
7. the method validates the credentials
8. if valid it gets added to the security context
9. if invalid it denies the request